pragma solidity ^0.4.24;

import "./Ownable.sol";
import "./ERC721Interface.sol";

contract Bridge is Ownable {
    
    address contact;
    uint consensus = 2;
    
    mapping (address => bool) recoverPermissions;
    mapping (address => bool) demolishPermissions;
    mapping (string => bytes32) tokenHashes;
    mapping (bytes32 => uint) validatorsCount;

    event userRequestForSignature(address owner, string tokenVIN, bytes data);
    event transferCompleted(address owner, string tokenVIN);
    
    modifier onlyAdmittedForRecover() {
        require (recoverPermissions[msg.sender] != false);
        _;
    }
    
    modifier onlyAdmittedForDemolish() {
        require (demolishPermissions[msg.sender] != false);
        _;
    }
    
    constructor(address main) public {
        contact = main;
    }
    
    function onERC721Received(address _from, string _tokenVIN, bytes data) external onlyAdmittedForDemolish {
        ERC721Interface(contact).transferFrom(_from, this, _tokenVIN);
        emit userRequestForSignature(_from, _tokenVIN, data);
    }
    
    function transferApprove(uint256 txHash, address owner, string _tokenVIN, bytes data) external onlyAdmittedForRecover {
        
       
        bytes32 tHash = getTransactionHash(txHash, owner, _tokenVIN, data);
        
        
        if (tokenHashes[_tokenVIN] == 0) {
            tokenHashes[_tokenVIN] = tHash;
            validatorsCount[tHash] += 1;
        } else if (tokenHashes[_tokenVIN] == tHash){
            validatorsCount[tHash] += 1;
        } 
        
        if (consensus == validatorsCount[tHash]){
             ERC721Interface(contact).recoveryToken(owner, _tokenVIN, data);
        emit transferCompleted(owner, _tokenVIN);
        }
       
     
    }
    
    function setPermissionToRecover (address user) external onlyOwner {
        recoverPermissions[user] = true;
    }
  
    function deniedPermissionToRecover (address user) external onlyOwner {
        recoverPermissions[user] = false;
    }
  
    function setPermissionToDemolish (address user) external onlyOwner {
        demolishPermissions[user] = true;
    }
  
    function deniedPermissionToDemolish (address user) external onlyOwner {
        demolishPermissions[user] = false;
    }
    
    function getTransactionHash(uint256 txHash, address _from, string _tokenVIN, bytes data) internal returns(bytes32) {
        return keccak256(txHash, _from, _tokenVIN, data);
    }
    
    function requiredAmountOfSigns(bytes32 tokenHash) internal {
        require(validatorsCount[tokenHash] >= consensus);
    }
}
